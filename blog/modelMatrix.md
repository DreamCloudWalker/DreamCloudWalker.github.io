## 前置知识
OpenGL一般它被认为是一个API(Application Programming Interface, 应用程序编程接口)，包含了一系列可以操作图形、图像的函数和数据结构。是一个由Khronos组织制定并维护的规范。具体的OpenGL的驱动程序实现，由显卡厂商实现或软件模拟(如Mesa 3D，ANGLE等)。
OpenGL ES：即 "OpenGL for Embedded Systems"，如移动电话、平板电脑和游戏机。由于硬件资源（如内存和性能）的限制，OpenGL ES 更加轻量化。
早期的OpenGL使用固定渲染管线。从OpenGL 2.0开始固定管线和可编程管线并存，从3.2版本开始抛弃固定管线。 OpenGL ES从2.0开始支持可编程渲染管线。

## 向量
向量最基本的定义就是一个方向。或者更正式的说，向量有一个方向(Direction)和大小(Magnitude，也叫做强度或长度)。
由于向量是一个方向，所以有些时候会很难形象地将它们用位置(Position)表示出来。为了让其更为直观，我们通常设定这个方向的原点为(0, 0, 0)，然后指向一个方向，对应一个点，使其变为位置向量(Position Vector)。比如说位置向量(1, 2)在图像中的起点会是(0, 0)，并会指向(1, 2)。
和普通数字一样，我们也可以用向量进行多种运算。

#### 向量与标量运算
标量(Scalar)只是一个数字（或者说是仅有一个分量的向量）。当把一个向量加/减/乘/除一个标量，我们可以简单的把向量的每个分量分别进行该运算。

#### 向量取反
对一个向量取反(Negate)会将其方向逆转。一个指向东北的向量取反后就指向西南方向了。我们在一个向量的每个分量前加负号就可以实现取反了（或者说用-1数乘该向量）

#### 向量加减
向量的加法可以被定义为是分量的(Component-wise)相加，即将一个向量中的每一个分量加上另一个向量的对应分量：
向量v = (4, 2)和k = (1, 2)可以直观地表示为：
![vector_plus](/pics/vector_plus.jpg)

两个向量的相减会得到这两个向量指向位置的差。这在我们想要获取两点的差会非常有用。
![vector_minus](/pics/vector_minus.jpg)

#### 长度
我们使用勾股定理(Pythagoras Theorem)来获取向量的长度(Length)/大小(Magnitude)。如果你把向量的x与y分量画出来，该向量会和x与y分量为边形成一个三角形:
因为两条边（x和y）是已知的，如果希望知道斜边v
的长度，我们可以直接通过勾股定理来计算：
|| v || = sqrt(x^2 + y^2)
有一个特殊类型的向量叫做单位向量(Unit Vector)。单位向量有一个特别的性质——它的长度是1。我们可以用任意向量的每个分量除以向量的长度得到它的单位向量。

#### 向量相乘

##### 点乘
两个向量的点乘等于它们的数乘结果乘以两个向量之间夹角的余弦值。
v⋅k = ||v||⋅||k||⋅cosθ
现在点积只定义了两个向量的夹角。你也许记得90度的余弦值是0，0度的余弦值是1。使用点乘可以很容易测试两个向量是否正交(Orthogonal)或平行（正交意味着两个向量互为直角）。
要计算两个单位向量间的夹角，我们可以使用反余弦函数cos^(−1) ，可得结果是143.1度。现在我们很快就计算出了这两个向量的夹角。点乘会在计算光照的时候非常有用。

##### 叉乘
叉乘只在3D空间中有定义，它需要两个不平行向量作为输入，生成一个正交于两个输入向量的第三个向量。如果输入的两个向量也是正交的，那么叉乘之后将会产生3个互相正交的向量。

## 齐次坐标
齐次坐标使用4个分量来表示三维空间中的点或向量。前三个分量和普通坐标一样，点的第四个分量为1，向量的第四个分量为0。
齐次坐标的优点是能够区分点和向量比如，平移一个点是有意义的，能够得到平移后的点坐标；而平移一个向量是没有意义的，方向不会因为平移而改变。

## 模型矩阵

OpenGL 的模型矩阵（Model Matrix）是用于描述物体在三维空间中位置、方向和缩放的变换矩阵。它是一种通过线性变换（平移、旋转和缩放）来控制场景中物体的姿态以及相对于世界坐标系的位置的工具。
   - 在 OpenGL 中，模型矩阵通常用于将模型空间中的顶点坐标转换为世界空间坐标。模型矩阵的组成通常包括三个部分：
     - **平移（Translation）**：物体在世界空间中的位置。
     - **旋转（Rotation）**：物体在世界空间中的方向。
     - **缩放（Scaling）**：物体的大小。

   - 模型矩阵是通过相应的旋转、平移和缩放矩阵相乘而得到的。矩阵有一个性质，M·（A·B） = （M·A）·B，考虑一个点，先进行了一次平移变换，又进行了一次旋转变换，结合上面矩阵的性质，可知变换后的点P’为：P` = R·（T·P） = （R·T）·P 。
   - 旋转矩阵和平移矩阵的乘积R•T也是一个4×4的矩阵，这个矩阵代表了一次平移变换和一次旋转变换效果的叠加；如果这个点还要进行变换，只要将新的变换矩阵按照顺序左乘这个矩阵，得到的新矩阵能够表示之前所有变换效果的叠加，将最初的点坐标左乘这个矩阵就能得到一系列变换后最终的点坐标，这个矩阵称为“模型矩阵”。一个模型矩阵乘以另一个模型矩阵得到的还是一个模型矩阵，表示先进行右侧模型矩阵代表的变换，再进行左侧模型矩阵代表的变换这一过程的效果之和，因此模型矩阵的乘法又可以认为是闭合的。

   - 具体推导过程如下（假设我们有一个物体应用了平移、旋转和缩放）：

       - 平移矩阵 T = 
                <table>
                <tr>
                    <td>1</td>
                    <td>0</td>
                    <td>0</td>
                    <td>tx</td>
                </tr>
                <tr>
                    <td>0</td>
                    <td>1</td>
                    <td>0</td>
                    <td>ty</td>
                </tr>
                <tr>
                    <td>0</td>
                    <td>0</td>
                    <td>1</td>
                    <td>tz</td>
                </tr>
                <tr>
                    <td>0</td>
                    <td>0</td>
                    <td>0</td>
                    <td>1</td>
                </tr>
                </table>

       - 旋转矩阵（绕x轴） R = 
                <table>
                <tr>
                    <td>1</td>
                    <td>0</td>
                    <td>0</td>
                    <td>0</td>
                </tr>
                <tr>
                    <td>0</td>
                    <td>cos(θ)</td>
                    <td>-sin(θ)</td>
                    <td>0</td>
                </tr>
                <tr>
                    <td>0</td>
                    <td>sin(θ)</td>
                    <td>cos(θ)</td>
                    <td>0</td>
                </tr>
                <tr>
                    <td>0</td>
                    <td>0</td>
                    <td>0</td>
                    <td>1</td>
                </tr>
                </table>

       - 旋转矩阵（绕y轴） R = 
                <table>
                <tr>
                    <td>cos(θ)</td>
                    <td>0</td>
                    <td>sin(θ)</td>
                    <td>0</td>
                </tr>
                <tr>
                    <td>0</td>
                    <td>1</td>
                    <td>0</td>
                    <td>0</td>
                </tr>
                <tr>
                    <td>-sin(θ)</td>
                    <td>0</td>
                    <td>cos(θ)</td>
                    <td>0</td>
                </tr>
                <tr>
                    <td>0</td>
                    <td>0</td>
                    <td>0</td>
                    <td>1</td>
                </tr>
                </table>

       - 旋转矩阵（绕z轴） R = 
                <table>
                <tr>
                    <td>cos(θ)</td>
                    <td>−sin(θ)</td>
                    <td>0</td>
                    <td>0</td>
                </tr>
                <tr>
                    <td>sin(θ)</td>
                    <td>cos(θ)</td>
                    <td>0</td>
                    <td>0</td>
                </tr>
                <tr>
                    <td>0</td>
                    <td>0</td>
                    <td>1</td>
                    <td>0</td>
                </tr>
                <tr>
                    <td>0</td>
                    <td>0</td>
                    <td>0</td>
                    <td>1</td>
                </tr>
                </table>

       - 缩放矩阵 S = 
                <table>
                <tr>
                    <td>sx</td>
                    <td>0</td>
                    <td>0</td>
                    <td>0</td>
                </tr>
                <tr>
                    <td>0</td>
                    <td>sy</td>
                    <td>0</td>
                    <td>0</td>
                </tr>
                <tr>
                    <td>0</td>
                    <td>0</td>
                    <td>sz</td>
                    <td>0</td>
                </tr>
                <tr>
                    <td>0</td>
                    <td>0</td>
                    <td>0</td>
                    <td>1</td>
                </tr>
                </table>

组合这些变换矩阵，通常顺序为先缩放，后旋转，最后平移，由于OpenGL是左乘，得到模型矩阵 M：

       M = T * R * S

注意矩阵乘法的顺序对于最终变换的结果是至关重要的。

尝试在Demo屏幕上拖动或用Demo提供的glRotate, glTranslate, glScale工具改变飞机的模型矩阵观察变化。